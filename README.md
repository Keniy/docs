1.HTML语义化 <header>,<footer>,<nav>等h5新的语义化标签与div有什么区别？
  1.为了搜索引擎更好的检索
  2.为了实现浏览器特定的功能 比如：阅读功能
  3.便于编程人员理解

2.Css3动画与JS动画的区别
JS动画：
缺点：1. JS在浏览器的主线程中运行，而主线程中还有其他需要运行的JS脚本、样式计算、布局、绘制任务等，对于干扰线程可能会出现阻塞，从而造成丢帧的情况。
2. 代码的负责度高于CSS动画
优点：1.  JS动画控制能力强，可以在动画播放过程中进行控制：开始、暂停、回放、终止、取消等。
2. 动画效果比CSS动画更丰富，有些动画效果，比如曲线运动，冲击闪烁，视察滚动等，只有JS动画才能实现。
3. CSS3有兼容性问题，而JS大多时候没有兼容性问题。
CSS3动画：
缺点：1. 运行过程控制较弱，无法附加事件绑定回调函数。CSS动画只能暂停，不能在动画中寻找一个特点的时间点，不能在半路中反转动画，不能在特定的位置添加回调函数或是绑定回放事件，无进度报告。
2. 代码冗长。想用CSS实现稍微复杂一点的动画，代码最终都会变得非常笨重。
优点：1. 浏览器可以对动画进行优化
浏览器使用与类似requestAnimationFrame的机制， requestAnimationFrame比起	setTimeout，setInterval设置动画的优势主要是: (1) requestAnimationFrame会把每一帧中	所有的DOM操作集中起来，在一次重绘货回流中就完成，并且重绘或回流的时间间隔紧随浏	览器的刷新频率，一般来说，这个频率为每秒60帧。(2) 在隐藏或者不可见的元素中, 	requestAnimationFrame不会进行重绘或回流，这意味着更少的cpu，gpu和内存使用量。
强制使用硬件加速 (通过GPU来提高性能)

3.Css3动画流畅的原因
渲染线程分为main thread（主线程）和compositor thread（合成器线程）
在主线程中，维护了一颗Layer树（LayerTreeHost），管理了TiledLayer, 在compositor thread，维护了同样的一颗LayerTreeHostImpl，管理了LayerImpl，两棵树的内容是拷贝关系。因此可以彼此不干扰，当JS在main thread操作layerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当JS繁忙导致主线程卡主时，合成到屏幕的过程也是流畅的。
为了实现防假死，鼠标键盘消息首先会被分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息。比如：鼠标滚动时，假如main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的页面将会刷白）。

4.JQuery（）方法的构建原理
JQuery中最常用的方法就是JQuery(), 也即$()
jQuery（）是一个函数调用，结果是返回一个JQuery实例对象。

要理解上述结构中的工作原理，必须理解JS基于构造函数与原型的继承模式。
当函数调用表达式前出现了New关键字，这个额函数就成了构造函数，此时会依次发生四件事：
1.首先一个空对象（实例）被创建
2.该实例继承构造函数的原型中的属性和方法。这也是为什么要把方法写在构造函数的prototype中。
3.该实例被赋值到构造函数内部的this对象
4.执行构造函数。如果构造函数中显式的返回了一个对象，那么new出的就不再是新建的空对象，而是return指定的对象。否则一律返回空对象。
于是JQuery（）的构造原理就出来了：每次调用JQuery（）都返回由构造函数指定返回的this对象，而this对象已经被赋值为那个新创建的空对象。由于JQuery.Prototype都赋值给了init.Prototype，所以新创建的空对象继承所有JQuery方法。

5.JS中this的指向
This的指向在函数定义时是确定不了的，只有在函数执行的时候才能确定this到底指向谁，实际this的最终指向，实际这个定义不太准确。

6.Http和Tcp/ip的区别
Http是一种应用层的协议，TCP是网络层协议，WEB利用Http应用层协议去封装Http的文本信息，然后通过TCP/IP网络层协议发送到网络上。
常见的应用层协议有SMTP、SSH、FTP、Telnet等等。

7.Http三次握手
Http（Hyper Text Transfer Protocol）超文本传输协议是互联网应用最为广泛的一种网络协议。由于信息是明文传输的，所以被认为不安全。而关于Http的三次握手，其实就是三次TCP握手确认建立一个Http连接。
如下图所示，SYN(synchronous)是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Ackknowledge number(确认号码),三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传输数据。

第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户端的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

8.CA证书是什么？
CA(Certificate Authority)是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任、认可的。
CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对Https）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其他证书都要依靠上一级证书来证明自己。

9.Https握手过程
Https在Http的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。

1.客户端发起Https请求
2.服务器的配置
采用Https协议的服务器必须要有一套数字证书，可以是自己制作的或者是CA证书。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。
3.传送证书
这个证书其实就是公钥，里面包含很多信息，如证书的颁发机构、过期时间等。
4.客户端解析证书
这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发生异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。
5.传送加密信息
这部分传送的是用证书加密过的随机值，目的就是让服务器得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值进行加密解密了。
6.服务端解密信息
服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。所谓的对称加密就是，把信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7.传输加密后的信息
这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。
8.客户端解密信息
客户端用之前生成的私钥解密服务端传送过来的信息，于是获取到了解密后的内容。

10.Https和Http的区别
1.https协议需要到CA申请证书或自制证书。
2.http的信息是明文传输，https是具有安全性的SSL加密
3.http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443
4.http的连接很简单，是无状态的；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
PS：Https一般使用的加密与HASH算法如下：
非对称加密算法：RSA，DSA/DSS
对称加密算法：AES，RC4，3DES
HASH算法：MD5，SHA1，SHA256

11.HTTP/1.1和HTTP/1.0协议的区别，HTTP/2.0的特性
1.缓存处理
2.带宽优化及网络连接的使用
3.错误通知的管理
4.消息在网络中发送
5.互联网地址的维护
6.安全性及完整性

HTTP/1.1状态码及其含义
状态代码由三位数字组成，第一个数字定义了响应的级别，且有五种可能取值：
1XX：指示信息--表示请求已被接收，继续处理
2XX：成功--表示请求已被成功接收、理解、接受
3XX：重定向--要完成请求必须进行更进一步的操作
4XX：客户端错误--请求有语法错误或请求无法实现
5XX：服务器端有错误--服务器未能实现合法的请求

HTTP/2.0
HTTP/2.0比之前的协议在性能上有了很大的提升。下面中介了HTTP/2.0的几个特性。
1.多路复用（Multiplexing）
多路复用允许同时通过单一的HTTP/2连接发起多重的请求-响应消息。在HTTP/1.1协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制。超过限制数目的请求会被阻塞。这也是为何有一些站点会有多个静态资源CDN域名的原因之一，拿Twitter为例，http://twimg.com,目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而HTTP/2的多路复用（Multiplexing）则允许同时通过单一的HTTP/2连接发起多重的请求-响应消息。因此HTTP/2可以很容易的去实现多流并行而不用依赖建立多个TCP连接，HTTP/2把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行的在同一个TCP连接上双向交换消息。

2.二进制分帧
HTTP/2在应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层。在不改动HTTP/1.x的语义、方法、状态码、URI以及首部字段的情况下，解决了HTTP/1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中，HTTP/2会将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码，其中HTTP/1.x的首部信息会被封装到HEADER frame，而相应的Request Body则封装到DATA frame里面。
HTTP/2通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去，HTTP性能优化的关键并不在于高带宽，而是低延迟。TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为TCP慢启动。由于这种原因，让原本具有突发性和短时行的HTTP连接变得十分低效。HTTP/2通过让所有数据流公用同一个连接，可以更有效地使用TCP连接，让高带宽也能真正的服务于HTTP的性能提升。
这种单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大；而且由于TCP连接的减少而使网络拥塞情况得以改善，同时慢启动时间的减少，使拥塞和丢包恢复速度更快。

3.首部压缩（Header Compression）
HTTP/1.1并不支持HTTP首部压缩，为此SPDY和HTTP/2应运而生，SPDY使用的是通用的DEFLATE算法，而HTTP/2则使用了专门为首部压缩而这设计的HPACK算法。

4.服务端推送（Server Push）
服务端推送是一种在客户端请求之前发送数据的机制。在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。Server Push让HTTP1.x时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo以及样式表，因为它知道客户端会用到这些东西。这相当于在一个HTML文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

12.JSON.parse与eval的区别
JSON.parse
MDN对JSON的描述，能解析的JSON字符串的条件完整如下：
1.js类型：对象和数组
属性名称必须用双引号包裹； 最后一个属性后面不能有引号；
2.js类型：数值
前导0不能使用（在JSON.stringify中会被忽略，在JSON.parse会抛出错误）;
小数点后面至少有一个数字
3.js类型：字符串
只有有限的字符能够被转义；不允许某些控制字符；但允许使用Unicode行分隔符（U+2028）和段落分隔符（U+2029）；字符串必须要双引号括起来

Eval
eval函数可以将一个JavaScript代码字符串求值成特定的对象，所以解析成JSON对象只不过是作用之一。
为什么eval()解析JSON字符串要加上括号？
原因有两点：
1.json对象是以“{}”的方式来开始以及结束的，在JS中，它会被当成一个语句块来处理。
2.加上圆括号是为了处理字符串为表达式，而不是语句（statement）来执行。

Eval是强烈不建议用来解析JSON字符串的，除非数据来源于你信任并且格式也不大规范。
13.Webpack的理解
Entry: 用来写入口文件，它将是整个依赖关系的根，通常把entry写成一个对象

Output: 即使入口文件有多个，但是只能有一个输出配置，如果定义的入口文件有多个，那么需要使用占位符来确保输出文件的唯一性。

Loader
Loader的作用：
1.实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js。
2.转换这些文件，从而使其能够被添加到依赖图中。
Loader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置

Plugins
plugins和loader很容易搞混，事实上两者是完全不同的东西。Loaders负责的是处理源文件如css,jsx, 一次处理一个文件。而plugins并不是直接操作单个文件，它直接怼整个构建过程起作用。下面列表一些常用的plugins和它的用法
Extract-text-webpack-plugin:它会将入口中引用的css文件，都打包到独立的css文件中，而不是内嵌在js打包文件中。

Html-webpack-plugin: 依据一个简单的index.html模板，生成一个自动引用你打包后的js文件的新index.html

Hot-module-replacement-plugin: 它允许在修改组件代码时，自动刷新实时预览修改后的结果。注意：永远不要在生产环境中使用。一般是在开发环境中使用。

常用的插件：
OccurenceOrderPlugin：为组件分配ID，通过这个插件webpack可以分析和优先考虑最多的模块，然后为他们分配最小的ID
UglifyJSPlugin：压缩代码

14.JS判断数组


15.Ajax的优缺点
优点：减轻服务器的负担，按需取数据，最大程度减少冗余请求，局部刷新。
缺点：浏览器之间的差异，对流媒体和移动设备支持不够好


16.谈谈对前端安全的理解，有什么，怎么防范
前端安全问题主要有XSS，CSRF攻击
XSS：跨站攻击
它允许用户将恶意代码植入到提供给其他用户使用的页面中，可以简单的理解为是一种JavaScript代码注入。
XSS的防范措施:
1.过滤转义输入输出
2.避免使用eval、new Function等执行字符串的方法，除非确定字符串和用户输入无关。
3.使用cookie的httpOnly属性，加上这个属性的cookie字段，js是无法进行读写的
4.使用innerHTML、document.write的时候，如果数据是用户输入的，那么需要对关键字符进行过滤和转义。
CSRF：跨站请求伪造
其实就是网站中的一些提交行为，被黑客利用，在你访问黑客的网站的时候进行操作，会被操作到其他网站上。
CSRF防御措施：
1.检测http referer是否同域名
2.避免登录的session长时间存储在客户端中
3.关键请求使用验证码或者token机制
其他的还有一些攻击方法如HTTP劫持、界面操作劫持等。

17.前端常见的性能优化有哪些
静态资源CDN，减少DOM操作（事件代理，fragment），压缩JS、css和HTML等，DNS与解析。

18.同源和跨域
什么是同源策略？
限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。
一个源指的是主机名、协议和端口号的组合，必须相同。
跨域通信的几种方式
1.JSONP
2.Hash
3.postMessage
4.Websocket
5.CORS

JSONP的原理
利用script标签的异步加载特性实现
给服务端传一个回调函数，服务端返回一个传递过去的回调函数名称的JS代码

19.深拷贝和浅拷贝
浅拷贝只复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（内存没有隔离）。
深拷贝会创造一个一模一样的对象，新对象与原对象不共享内存（内存区域隔离），修改新对象不会改到原对象。在多层对象中，浅拷贝只会拷贝一层。

20.实现水平垂直居中有多少种方法？
1.绝对定位  盒子的宽高已知

2.父级Table-cell布局

3.绝对定位+transform 适用于盒子宽高不定时

4.父级flex布局

 	
21.如何理解盒子模型
盒子模型有两种，W3C和IE盒子模型
1.W3C的盒模型width=content，不包括margin,padding,border
2.IE的盒模型width=content+padding+border
3.Box-sizing border-box在已设定的宽度和高度之内去设定padding和border
Content-box在已设定的高度和宽度之外设置padding和border

22.如何让文本不可复制

添加版权信息思路：
1.答案区域监听copy事件，并阻止该事件的默认行为。
2.获取选中的内容（window.getSelection()）加上版权信息，然后设置到剪切板（clipboarddata.setData()）。

23.事件的各个阶段
1：捕获阶段 ---> 2：目标阶段 ---> 3：冒泡阶段
Document    ---> target目标  ---> document
由此，addEventListener的第三个参数设置为true和false的区别已经非常清晰：

True表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件；
False表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件。

24.作用域
域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么时候不能使用。
简单的说，作用域是针对变量的，比如我们创建一个函数a1, 函数里面又包了一个函数	a2。

如上图所示，此时存在三个作用域，a1，a2作用域；全局作用域包含了a1作用域，a2作用域包含了a1作用域。
当a2在查找变量的时候会先从自身的作用域区查找，找不到了再往上一级a1的作用域查找，如果还没好到就到全局作用域区查找，这样就形成了一个作用域链。

25.什么是闭包？
当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。
简单来说，所谓的闭包就是一个具有封闭的对外不公开的，包裹结构或空间。

闭包有什么用（特性）
闭包的作用，就是保存自己私有的变量，通过提供的接口（方法）给外部调用，但外部不能直接访问该变量。
当我们需要在模块中定义一些变量，并希望这些变量一直保存在内容中但又不会“污染”全局变量时，就可以用闭包来定义这个模块。

闭包的缺点：
常驻内存，会增大内存的使用量，使用不当很容易造成内存泄漏。

函数套函数就是闭包吗？
不是，当一个内部函数被其外部函数之外的变量引用时，才会形成一个闭包。

闭包的基本模型

对象模式
函数内部定义一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据。



函数模式
函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据



沙箱模式
沙箱模式就是一个自调用函数，代码写到函数中一样执行，但是不会与外界有任何的影响，比如jQuery



26.JS中call,bind,apply的作用
call和apply、bind是用来改变this的指向的，但是也有差别，看下图


第一个参数传的是你要借用的对象，但我们不需要，所以传了个null，除了第一个参数后面的参数将作为实际参数传入到函数中
call就是挨个传值，apply传一个数组，bind也是挨个传值，但是和call跟apply有区别，使用call和apply会直接执行这个函数，而bind则不会而是将绑定好的this重新返回给一个新函数，什么时候调用由你来决定。

27.Spring AOP原理
AOP （Aspect-Oriented Programming）, 面向切面编程。
一些系统层级的服务（例如安全、日志、事物），这些与业务逻辑无关的服务如果直接写在业务流程中，这样会使得业务流程到处都是这些服务代码，繁琐难维护，混淆业务本身的职责，还不容易剔除。
AOP的编程思想，是与业务逻辑无关的动作或业务，应当抽成一个服务，横切面（Cross-cutting）业务流程中，业务本身感知这些服务的存在，只需处理自己的业务逻辑。这样，添加或移除一个服务是非常容易的。
AOP核心概念
Aspect:：所有需横切入业务流程的服务对象
Adive：横切入服务的具体实现
JoinPoint：Advice横切入业务流程的点或时机。执行时机可以在某个方法被执行之前或之后，或方法中抛出异常。
Pointcut：定义一系列的JoinPoint，当调用方法服务Pointcut表达式时，将Advice横切入业务流程。
Target：被横切入服务的对象。
Introduction：一种特殊的Advice，可在执行时机为业务对象动态的加入一些方法或行为。
Proxy：Spring的AOP主要是通过动态代理完成的，也可以使用CGLIB代理。
Weave：Advice被应用到对象上的过程。有三个时间点：编译时期、类加载时期、执行时期。

28.Spring IOC和DI原理
控制反转（Inverseion of Control）IOC，一种模式，Spring的核心概念。
依赖注入（Dependency Injection）是实现IOC的一种方式。

控制反转
在传统模块调用，高层服务模块直接调用底层服务模块，高层模块对底层模块产生依赖，更换底层模块会导致高层模块跟着修改，这存在耦合。
在Spring里，高层模块不再直接调用底层模块，而是调用抽象接口，由容器完成底层模块实例化并注入高层模块里。高层模块对底层模块的控制权被撤销，由IOC容器接管，高层模块需要的对象由IOC容器提供，这就是控制反转。

依赖注入
依赖注入是当模块与其他模块发生依赖关系时，所依赖的模块由容器注入。
依赖注入的三种实现方式：
1.Interface injection（不推荐）
模块需要实现一个接口，接口包含创建依赖模块的方法，容器负责执行该方法来建立依赖关系。
2.Setter injection（推荐）
通过Setter注入依赖的对象
3.Constructor injection
在构造方法上注入依赖对象


